--!nonstrict
local Types = require(script:WaitForChild("Types"))
local Constants = require(script:WaitForChild("Constants"))
local Renderers	= require(script:WaitForChild("Renderers"))

--#region Services
local RunService = game:GetService("RunService")
local TextService = game:GetService("TextService")
local HttpService = game:GetService("HttpService")
--#endregion

--#region Type Definitions
export type Computable<T> = Types.Computable<T>
export type Enum<T> = Types.Enum<T>
export type Array<T> = Types.Array<T>

export type Callback = Types.Callback
export type Connection = Types.Connection
export type Connections = Types.Connections

export type SketchbookStatus = Types.SketchbookStatus
export type Sketchbook = Types.Sketchbook

export type Drawing = Types.Drawing
export type DrawingType = Types.DrawingType
export type DrawingParameters = Types.DrawingParameters
export type Renderer = Types.Renderer
--#endregion

local sketchbookRegistry: { Sketchbook } = {}

local function generateUUID(): string
	return (HttpService:GenerateGUID(false):gsub("-", ""):lower())
end

local function createEnum<T>(values: Array<T>): Enum<T> 
	local enum: Enum<T> = {}

	for _, value: T in ipairs(values) do
		enum[tostring(value)] = value
	end

	return table.freeze(enum)
end

local function isComputable(value: unknown, expectedType: string): boolean
	return typeof(value) == expectedType 
		or typeof(value) == "function"
end

local function cleanupConnection(connection: Connection): ()
	if typeof(connection) == "RBXScriptConnection" then
		connection:Disconnect()
	elseif typeof(connection) == "Instance" then
		connection:Destroy()
	elseif typeof(connection) == "function" then
		connection()
	end
end

--[=[
	A drawing is, as you might expect, a representation of data that will be drawn to the screen in each call of the render function.
	Each drawing is attached to a sketchbook, which is a collection of drawings that are all rendered together; it also acts as a container for
	different types of drawings, helping to keep your code nice and organized.
	
	```lua
	local sketchbook = Sketch.createSketchbook() -- Create a new sketchbook to hold our drawings
	local drawing = Sketch.drawText(sketchbook, "Hello, world!") -- Create a new drawing to draw some text
	```

	@class Drawing
	@tag component 
]=]
local Drawing
do
	Drawing = {}
	Drawing.__index = Drawing

	--#region Generate Drawing Parameters
	local function generateLineParameters(): DrawingParameters
		return {
			lineParams = {
				thickness = 1,
				points = {
					first = Vector3.new(0, 0, 0),
					second = Vector3.new(0, 0, 0)
				}
			}
		}
	end

	local function generateCircleParameters(): DrawingParameters
		return {
			circleParams = {
				radius = 1,
				filled = false,
				position = Vector3.new(0, 0, 0)
			}
		}
	end

	local function generateRectangleParameters(): DrawingParameters
		return {
			rectangleParams = {
				size = {
					width = 1,
					height = 1
				},

				filled = false,
				position = Vector3.new(0, 0, 0)
			}
		}
	end

	local function generateTriangleParameters(): DrawingParameters
		return {
			triangleParams = {
				points = {
					first = Vector3.new(0, 0, 0),
					second = Vector3.new(0, 0, 0),
					third = Vector3.new(0, 0, 0)
				},

				filled = false,
				position = Vector3.new(0, 0, 0)
			}
		}
	end

	local function generateTextParameters(): DrawingParameters
		return {
			textParams = {
				text = "Undefined", 
				position = Vector3.new(0, 0, 0),
				size = 1,
				font = Font.fromEnum(Enum.Font.SourceSans),
			}
		}
	end
	--#endregion

	local function generateParameters(drawing: Drawing): DrawingParameters
		local parameters: DrawingParameters

		if drawing.type == "Line" then
			parameters = generateLineParameters()
		elseif drawing.type == "Circle" then
			parameters = generateCircleParameters()
		elseif drawing.type == "Rectangle" then
			parameters = generateRectangleParameters()
		elseif drawing.type == "Triangle" then
			parameters = generateTriangleParameters()
		elseif drawing.type == "Text" then
			parameters = generateTextParameters()
		end

		return parameters
	end

	local function createRenderer(drawing: Drawing): Renderer
		if drawing.type == "Line" then
			return Renderers.LineRenderer.new(drawing, drawing:getSketchbook())
		elseif drawing.type == "Circle" then
			return Renderers.CircleRenderer.new(drawing)
		elseif drawing.type == "Rectangle" then
			return Renderers.RectangleRenderer.new(drawing)
		elseif drawing.type == "Triangle" then
			return Renderers.TriangleRenderer.new(drawing)
		elseif drawing.type == "Text" then
			return Renderers.TextRenderer.new(drawing)
		end
		
		error(("Drawing type %s is not supported"):format(drawing.type))
	end

	--[=[
		Creates a new drawing.

		@param sketchbook Sketchbook -- The sketchbook to create the drawing in
		@param type DrawingType -- The type of the drawing
		@within Drawing
		@return Drawing
	]=]
	function Drawing.new(sketchbook: Sketchbook, type: DrawingType): Drawing
		local self = setmetatable({}, Drawing)

		self.uuid = generateUUID()
		self.sketchbook = sketchbook

		self.type = type
		self.color = Color3.new(1, 1, 1)
		self.transparency = 0
		self.parameters = generateParameters(self)
		self.renderer = createRenderer(self)

		self._connections = ({} :: Connections?)

		return self
	end

	--[=[
		Get the sketchbook the drawing is in.

		@within Drawing
		@return Sketchbook
	]=]
	function Drawing:getSketchbook(): Sketchbook
		return self.sketchbook
	end

	--[=[
		Set the drawing's line thickness *(only applicable to line drawings)*.

		@param thickness number -- The thickness of the line
		@error "Cannot set line thickness of non-line drawing" -- The drawing is not a line drawing
		@within Drawing
		@return Drawing
	]=]
	function Drawing:setLineThickness(thickness: number): Drawing
		assert(self.type == "Line", "Cannot set line thickness of non-line drawing")

		self.parameters.lineParams.thickness = thickness

		return self 
	end

	--[=[
		Get the drawing's line thickness *(only applicable to line drawings)*.

		@error "Cannot set line thickness of non-line drawing" -- The drawing is not a line drawing
		@within Drawing
		@return number
	]=]
	function Drawing:getLineThickness(): number
		assert(self.type == "Line", "Cannot get line thickness of non-line drawing")

		return self.parameters.lineParams.thickness
	end

	--[=[
		Cleans up the drawing, removing it from the sketchbook, cleaning up the renderer, and disconnecting all events.

		@within Drawing
	]=]
	function Drawing:cleanup()
		self:getSketchbook():removeDrawing(self)
		self:getRenderer():cleanup()

		for _, connection in pairs(self._connections) do
			connection:disconnect()
		end

		self._connections = nil

		setmetatable(self, nil)
	end
end

--[=[
	A sketchbook is essentially a container that can hold sketched objects (which will then be rendered to the world at runtime).
	Each sketchbook has a unique ID that can be used to identify it, and can be be modified when necessary.
	
	@class Sketchbook
	@tag component
]=]
local Sketchbook
do
	Sketchbook = {}
	Sketchbook.__index = Sketchbook

	--[=[
		Creates a new sketchbook.

		@within Sketchbook
		@return Sketchbook
	]=]
	function Sketchbook.new(): Sketchbook
		local self = setmetatable({}, Sketchbook)

		self.uuid = generateUUID()
		self.status = "Alive"

		self._connections = ({} :: Connections)
		self._drawings = ({} :: Array<Drawing>)

		table.insert(sketchbookRegistry, self)

		return self
	end

	--[=[
		Registers a drawing to the sketchbook. This will also register the drawing's renderer and connect all events.

		@error "Cannot register drawing that is already registered" -- The drawing is already registered to the sketchbook
		@error "Cannot register drawing that is already registered to another sketchbook" -- The drawing is already registered to another sketchbook
		@param drawing Drawing -- The drawing to register
		@within Sketchbook
		@return Drawing -- The drawing that was registered
	]=]
	function Sketchbook:registerDrawing(drawing: Drawing): Drawing 
		assert(drawing, "Cannot register nil drawing")

		local alreadyRegistered: boolean = false

		for _, entry: Drawing in ipairs(self._drawings) do
			if entry.uuid == drawing.uuid then
				alreadyRegistered = true
				break
			end
		end

		assert(not alreadyRegistered, "Cannot register drawing that is already registered")
		assert(drawing:getSketchbook() == nil, "Cannot register drawing that is already registered to another sketchbook")

		table.insert(self._drawings, drawing)

		return drawing
	end

	--[=[
		Unregisters a drawing from the sketchbook. This will also unregister the drawing's renderer and disconnect all events.

		@param drawing Drawing -- The drawing to unregister
		@within Sketchbook
	]=]
	function Sketchbook:unregisterDrawing(drawing: Drawing)
		assert(drawing, "Cannot unregister nil drawing")

		local index: number = 0

		for i, entry: Drawing in ipairs(self._drawings) do
			if entry.uuid == drawing.uuid then
				index = i
				break
			end
		end

		assert(index ~= 0, "Cannot unregister drawing that is not registered")

		table.remove(self._drawings, index)

		return drawing
	end

	--[=[
		Gets all drawings registered to the sketchbook.

		@within Sketchbook
		@return Array<Drawing>
	]=]
	function Sketchbook:getDrawings(): Array<Drawing>
		return self._drawings
	end

	--[=[
		Sets the state of the sketchbook to be hidden or not.

		@error "Cannot set status of dead sketchbook" -- The sketchbook is dead
		@param hidden boolean -- Whether the sketchbook should be hidden or not
		@within Sketchbook
	]=]
	function Sketchbook:setHidden(hidden: boolean)
		assert(self.status ~= "Dead", "Cannot set status of dead sketchbook")

		self.status = (hidden and "Hidden" or "Alive")
	end

	--[=[
		Gets the status of the sketchbook.

		@within Sketchbook
		@return SketchbookStatus -- The status of the sketchbook
	]=]
	function Sketchbook:getStatus(): SketchbookStatus 
		return self.status
	end

	--[=[
		Cleans up the sketchbook, removing all drawings and connections.

		@within Sketchbook
	]=]
	function Sketchbook:cleanup()
		self.status = "Dead"
		
		for _, connection: Connection in ipairs(self._connections) do
			cleanupConnection(connection)
		end

		setmetatable(self, nil)
	end
end

--[=[
	An enum value to represent a sketchbook's status.

	@interface Status
	@tag enum
	@within Sketch
	.Alive "Alive" -- The sketchbook is alive and visible in the world
	.Hidden "Hidden" -- The sketchbook is hidden and cannot be seen in the world
	.Dead "Dead" -- The sketchbook is dead and can no longer be used
]=]
--[=[
	This is the API that used to create and modify drawings. It's essentially a wrapper that allows for
	easy creation of drawings and sketchbooks to hold said drawings.

	```lua
	local Sketch = require("?")

	local sketchbook: Sketch.Sketchbook = Sketch.createSketchbook()
	local drawing: Sketch.Drawing = Sketch.drawText(sketchbook, "Hello, world!")

	Sketch.render(sketchbook)

	-- 🎉 Tada, you've created and rendered a drawing! 
	-- Also, although not necessary, it's **highly** recommended you call the Sketch.render(...) function each frame as opposed to manually after you make changes)
	```

	@class Sketch
]=]
local Sketch = {
	Status = ({
		Alive = "Alive",
		Hidden = "Hidden",
		Dead = "Dead",
	} :: {
		[string]: DrawingType 
	})
}

--[=[
	Creates a sketchbook that can then contain other sketchable objects.
	
	```lua
	local sketchbook: Sketch.Sketchbook = Sketch.createSketchbook()
	```

	@return Sketchbook
]=]
function Sketch.createSketchbook(): Sketchbook
	return Sketchbook.new()
end

--[=[
	Creates a new text drawing and registers it in the provided sketchbook.

	```lua
	-- Create computables for the position, text, and color;
	-- Computables can either be a static value or a function that will be called every render call
	local position: Computable<Vector3> = Vector3.new(0, 0, 0)
	local text: Computable<string> = function()
		return "Hello, world!"
	end
	local color: Computable<Color3> = Color3.new(1, 1, 1)

	-- Create a new sketchbook and drawing
	local sketchbook: Sketchbook = Sketch.createSketchbook()
	local drawing: Drawing = Sketch.drawText(sketchbook, text, position, color)

	-- Render the sketchbook (and, in turn, all of its drawings) to the screen
	Sketch.render(sketchbook)
	```

	@param sketchbook Sketchbook -- The sketchbook to draw the text on
	@param text Computable<string> -- The text to draw
	@param position Computable<Vector3> -- The position to draw the text at
	@param color Computable<Color3> -- The color to draw the text in
	@within Sketch
	@return Drawing 
]=]
function Sketch.drawText(sketchbook: Sketchbook, text: Computable<string>, position: Computable<Vector3>?, color: Computable<Color3>?): Drawing
	assert(isComputable(text, "string"), "Invalid argument #2, expected Computable<string>")

	local drawing = Drawing.new(sketchbook, "Text")

	sketchbook:registerDrawing(drawing)

	--drawing:setText(text)
	--drawing:setColor(color or Color3.new(1, 1, 1))

	if position ~= nil then
	--	drawing:setTextPosition(position)
	end

	return drawing 
end

--[=[
	Creates a new line drawing and registers it in the provided sketchbook.

	```lua
	-- Create computables for the initial point XYZ, secondary point XYZ, color, and thickness;
	-- Computables can either be a static value or a function that will be called every render call
	local point1: Computable<Vector3> = function()
		return Vector3.new(0, math.sin(tick()), 0)
	end
	local point2: Computable<Vector3> = Vector3.new(1, math.cos(tick()), 0)
	local color: Computable<Color3> = Color3.new(1, 1, 1)
	local thickness: Computable<number> = 1

	-- Create a new sketchbook and drawing
	local sketchbook: Sketchbook = Sketch.createSketchbook()
	local drawing: Drawing = Sketch.drawLine(sketchbook, text, point1, point2, color, thickness)

	-- Render the sketchbook (and, in turn, all of its drawings) to the screen
	Sketch.render(sketchbook)
	```

	@param sketchbook Sketchbook -- The sketchbook to draw the text on
	@param point1 Computable<Vector3> -- The first point to draw the line between
	@param point2 Computable<Vector3> -- The second point to draw the line between
	@param color Computable<Color3> -- The color to draw the line in
	@param thickness Computable<number> -- The thickness of the line
	@tag unimplemented
	@unreleased
	@within Sketch
]=]
function Sketch.drawLine(sketchbook: Sketchbook, point1: Computable<Vector3>, point2: Computable<Vector3>, color: Computable<Color3>, thickness: Computable<number>): Drawing
	error("Not implemented")
end

--[=[
	Renders a sketchbook to the screen. Although not necessary, it is recommended that this function
	be called each frame instead of manually after each change to the sketchbook or its drawings.
	
	```lua
	local sketchbook = Sketch.createSketchbook()
	local drawing = Sketch.drawText(sketchbook, function()
		return "Hello, world!"
	end, Vector3.new(0, 5, 0), Color3.new(1, 1, 1))

	Sketch.render(sketchbook)
	```

	@param sketchbook Sketchbook -- The sketchbook to render
	@return nil
]=]
function Sketch.render(sketchbook: Sketchbook): ()
	for _, drawing: Drawing in pairs(sketchbook:getDrawings()) do
		local renderer: Renderer = drawing:getRenderer()
	end
end

--[=[
	Removes a drawing from a sketchbook. This function should be called when you are done with a drawing and no longer
	want it to be rendered or used.

	@param sketchbook Sketchbook -- The sketchbook to remove the drawing from
	@param drawing Drawing -- The drawing to remove
	@return nil
]=]
function Sketch.removeDrawing(sketchbook: Sketchbook, drawing: Drawing): ()
	sketchbook:unregisterDrawing(drawing)
	drawing:cleanup()
end

return Sketch
